In all of our three encodings we have used one variable for each free field next to a tree. If one field has two neighbouring trees for example, then there would also be two variables for this field, to differentiate if the tent is connected to the first or the second tree. We used clauses to ensure that each tree has exactly one tent. This is done by taking "OR" of all tents of this tree (at least one) and "NOT OR" of all possible pairs of tents. It is also quite straight forward to ensure that no tents touch each other. For all neighbouring (or at the same position) tents take "NOT OR" of both. The only real challenge is to encode the restriction that there are exactly n tents in a row or column. In our first attempt we ensured it by allowing for at most n tents and also at least n tents. If there are k tent variables in one row or column we ensured that at most n are true by combining all possible choices for n+1 variables out of k with "NOT OR". For example for 10 variables and 3 should be true, we took the 10 choose 4 possibilities combined with "NOT". So if four or more variables would be true, then at least one clause would be violated. To ensure that a least n are true we chose k-n+1 variables combined with "OR". In the example from above this means taking all 10 choose 8 combinations. If only two or fewer variables would be true, there would be a clause containing only the remaining 8 variables and so would be false. This encoding work well for small puzzles but scaled quite badly for bigger puzzles. The 25x30 puzzle already needed 5 minutes to solve and contained ca. 25 million clauses. Our first considerable improvement was not to treat all tents in a row equally. Since it is already clear that two tents at the same position can not both be true we combined them with "OR" and treated the result as a variable. Hence, we did not need to choose between all tent variables in a row or column but only between all tent positions. This reduced the time for the 30x25 puzzle to 20 seconds and to ca. 600000 clauses. Even so this was considerably faster, this method did still not scale well for bigger puzzles since the combinatorial possibilities of k choose n are growing exponentially and so we needed to find a completely new method. After some time we had the idea to use a deterministic finite automaton for the counting. The automaton has a quite simple structure.It goes through all positions in a row or column and if there is no tent it stays in the same state as before otherwise it goes to the next state in a linear fashion. This automaton can be modelled as a SAT problem by introducing variables for each state at each time step. Since the tent number either stays equal or grows by one, the transitions are also straight forward to model. For better efficiency we did not model all states at all time steps, since for example after one step their won't be two tents and also there is no way to have enough tents if two tents are missing one step before the end. The downside of this approach is that new variables have to be introduced, but it removes the exponential scaling of the other two approaches, so it is by far superior. The number of clauses was reduced to ca. 21000 and the duration to 50 ms for the 30x25.

The Sat struct has Version variable (1,2 or 3) which allows to switch between the three different encodings. 

We decided to use Rust for this project because we both have only very limited experience with this language but are very curios to learn more. Nevertheless we had to realize that for the GUI there are much fewer libraries available and also the documentation was in multiple ways (the actual documentation, stack overflow question, youtube tutorials and so on) limited compared to what we are used to from other languages. Therefore we implemented the GUI with python and called from there the rust encoder and cadical.   